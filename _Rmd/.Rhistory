# SysA Vs. SysB
wilcoxSysAvB <- wilcox.test(myDataPrefGrouped$sysA, myDataPrefGrouped$sysB,
paired = T, correct = F)
# SysA Vs. No Opinion
wilcoxSysAvNo <- wilcox.test(myDataPrefGrouped$sysA, myDataPrefGrouped$NoOpinion,
paired = T, correct = F)
# SysB Vs. No Opinion
wilcoxSysBvNo <- wilcox.test(myDataPrefGrouped$sysB, myDataPrefGrouped$NoOpinion,
paired = T, correct = F)
# Print out the unadjusted wilcoxon results
rFromWilcox(wilcoxSysAvB, 50)
rFromWilcox(wilcoxSysAvNo, 50)
rFromWilcox(wilcoxSysBvNo, 50)
# As a last move, we can use a holm-Bonferroni correction on the p values
pVal <- c(wilcoxSysAvB$p.value, wilcoxSysAvNo$p.value, wilcoxSysBvNo$p.value)
p.adjust(pVal, method = "holm")
```
So from this analysis, we can show that there were statistical differences in the number of times participants preferred the Control UI (Mdn = 1), the Modified UI (Mdn = 5) and selected No Opinion (Mdn = 4).
We can also show that statistically, the Modified UI was preferred more often to the Control UI: Z = -4.053, p < .001, r = -.573. The Modified UI was also selected more often to No Opinion: Z = -2.043, p = .041, r = -.289. And finally, No Opinion was selected more often than the Control UI: Z = -2.989, p = .006, r = -.422.
?predict()
?kruskal.test()
x <- runif(10)
x
?runif()
y <- 5 + 2.7 * x + rnorm(10, mean = 0, sd=sqrt(0.15))
y
plot(y)
regLin <- lm(y~x)
summary(regLin)
y_star2<- predict(regLin)
summary(y_star2)
ystar1 <- coef[1] + coef[2] * x
?predict()
x <- rnorm(15)
x
plot(x)
y <- x + rnorm(15)
predict(lm(y ~ x))
predict(lm(y ~ x), data.frame(x = seq(-3, 3, 0.1)), se = TRUE)
x <- seq(1:10)
y <- (x * 2)
reg <- lm(x ~ y)
plot(x, y)
reg
summary(reg)
predict(lm, reg, 4)
?predict()
predict(reg, 4)
predict(reg, newdata=4)
predict(reg, c(4))
predict(reg, c(4), interval = none)
predict(reg, c(4), interval = "none")
predict(reg, data.frame(x = c(4.5), interval = "none")
)
predict(reg, data.frame(x = c(4.5)), interval = "none")
predict(reg, data.frame(x = c(4.5, 7)), interval = "none")
predict(reg, data.frame(x = 4.5), interval = "prediction")
reg <- lm(y ~ x)
predict(reg, newdata = 4.5, interval = "prediction")
predict(reg, x = 4.5, interval = "prediction")
summary(reg)
predict(reg, x = 4.5, interval = "none")
predict(reg, x = 4.5, interval = "confidence")
pred <- predict(reg, interval = "confidence")
summary(pred)
h1 = 4.5
beta0 <- reg[["coefficients"]][1]
beta1 <- reg[["coefficients"]][2]
y <- beta0 + beta1*h1
y
install.packages(c("boot", "car", "class", "cluster", "codetools", "DBI", "digest", "dplyr", "evaluate", "foreign", "formatR", "ggplot2", "gsubfn", "highr", "KernSmooth", "knitr", "labeling", "lattice", "markdown", "MASS", "Matrix", "mgcv", "nlme", "nnet", "RColorBrewer", "Rcpp", "RCurl", "reshape", "reshape2", "rjson", "ROAuth", "rpart", "RSQLite", "scales", "spatial"))
install.packages("installr")
install.packages("installr")
library(installr)
library(installR)
library("installr")
install.packages("updater")
install.packages("updateR")
install.packages("installR")
install.packages("installr")
install.packages("installr")
install.packages("installr")
pf <- read.csv('~/R/EDA_Course_Materials/lesson3/pseudo_facebook.tsv', sep = '\t')
library(data.table)
pf <- as.data.table(pf)
pf[age < 25, list(friends = mean(friend_count)), by=c("gender", "age")]
pf[age < 25 & !is.na(gender), list(friends = mean(friend_count)), by=c("gender", "age")]
library(plyr)
library(dplyr)
pf[age < 25 & !is.na(gender), list(friends = mean(friend_count)), by=c("gender", "age")] %>% ggplot(aes(age, friends), group="gender") + geom_bar(stat="identity", binwidth=1, color = "black", fill = "skyblue")
library(ggplot)
library(ggplot2)
pf[age < 25 & !is.na(gender), list(friends = mean(friend_count)), by=c("gender", "age")] %>% ggplot(aes(age, friends), group="gender") + geom_bar(stat="identity", binwidth=1, color = "black", fill = "skyblue")
pf[age < 25 & !is.na(gender), list(friends = mean(friend_count)), by=c("gender", "age")] %>% ggplot(aes(age, friends), group="gender") + geom_density(color = "black", fill = "skyblue")
pf[age < 25 & !is.na(gender), list(friends = mean(friend_count)), by=c("gender", "age")] %>% ggplot(aes(age, friends), group="gender") + geom_density(color = "black", fill = "skyblue")
pf[age < 25 & !is.na(gender), list(friends = mean(friend_count)), by=c("gender", "age")] %>% ggplot(aes(age, friends)) + geom_density(color = "black", fill = "skyblue")
pf[age < 25 & !is.na(gender), list(friends = mean(friend_count)), by=c("gender", "age")] %>% ggplot(aes(age, friends)) + geom_density(color = "black", fill = "skyblue")
View(pf)
View(pf)
pf[age > 60, length(unique(userid)), by=c("age", "gender")]
pf[age > 60, length(unique(userid)), by=c("age", "gender")] %>% ggplot(aes(age)) + geom_bar(binwidth=1)
library(installr)
install.packages("install4")
install.packages("installr")
install.packages("installr")
install.packages("updater")
install.packages("installR")
install.packages("installr")
install.packages(installr)
install.packages(c("boot", "chron", "class", "cluster", "codetools", "foreign", "KernSmooth", "lattice", "manipulate", "MASS", "Matrix", "mgcv", "nlme", "nnet", "plyr", "R6", "Rcpp", "rpart", "scales", "spatial", "stringi", "survival"))
install.packages("installr")
a <- "Chloe is a cock"
a
View(a)
for (i in 1:100) { print(a)}
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
rm(a, i)
rmd2md <- function( path_site = getwd(),
dir_rmd = "_rmd",
dir_md = "_posts",
#dir_images = "figures",
url_images = "figures/",
out_ext='.md',
in_ext='.rmd',
recursive=FALSE) {
require(knitr, quietly=TRUE, warn.conflicts=FALSE)
#andy change to avoid path problems when running without sh on windows
files <- list.files(path=file.path(path_site,dir_rmd), pattern=in_ext, ignore.case=TRUE, recursive=recursive)
for(f in files) {
message(paste("Processing ", f, sep=''))
content <- readLines(file.path(path_site,dir_rmd,f))
frontMatter <- which(substr(content, 1, 3) == '---')
if(length(frontMatter) >= 2 & 1 %in% frontMatter) {
statusLine <- which(substr(content, 1, 7) == 'status:')
publishedLine <- which(substr(content, 1, 10) == 'published:')
if(statusLine > frontMatter[1] & statusLine < frontMatter[2]) {
status <- unlist(strsplit(content[statusLine], ':'))[2]
status <- sub('[[:space:]]+$', '', status)
status <- sub('^[[:space:]]+', '', status)
if(tolower(status) == 'process') {
#This is a bit of a hack but if a line has zero length (i.e. a
#black line), it will be removed in the resulting markdown file.
#This will ensure that all line returns are retained.
content[nchar(content) == 0] <- ' '
message(paste('Processing ', f, sep=''))
content[statusLine] <- 'status: publish'
content[publishedLine] <- 'published: true'
#andy change to path
outFile <- file.path(path_site, dir_md, paste0(substr(f, 1, (nchar(f)-(nchar(in_ext)))), out_ext))
#render_markdown(strict=TRUE)
#render_markdown(strict=FALSE) #code didn't render properly on blog
#andy change to render for jekyll
render_jekyll(highlight = "pygments")
#render_jekyll(highlight = "prettify") #for javascript
opts_knit$set(out.format='markdown')
# andy BEWARE don't set base.dir!! it caused me problems
# "base.dir is never used when composing the URL of the figures; it is
# only used to save the figures to a different directory.
# The URL of an image is always base.url + fig.path"
# https://groups.google.com/forum/#!topic/knitr/18aXpOmsumQ
opts_knit$set(base.url = "/")
opts_chunk$set(fig.path = url_images)
#andy I could try to make figures bigger
#but that might make not work so well on mobile
#opts_chunk$set(fig.width  = 8.5,
#               fig.height = 5.25)
try(knit(text=content, output=outFile), silent=FALSE)
} else {
warning(paste("Not processing ", f, ", status is '", status,
"'. Set status to 'process' to convert.", sep=''))
}
} else {
warning("Status not found in front matter.")
}
} else {
warning("No front matter found. Will not process this file.")
}
}
invisible()
}
rmd2md()
library(knitr)
library(rmarkdown)
??rmarkdown
knit()
knit("---
title: "test"
author: "Chris Norval"
date: "15 November 2015"
output:
md_document:
variant: markdown_github
---
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.
When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
```{r}
summary(cars)
```
You can also embed plots, for example:
```{r, echo=FALSE}
plot(cars)
```
Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
")
]]
]]
[[]]
[]]]
}}}
}}
}
}
}
}
}}
asdf
asdf
q
we
r
qwerqwe
ls
getwd()
knit("test.Rmd")
knit2html("test.md")
myjekyllsite = c("http://cnorval.github.io/")
KnitPost <- function(input, base.url = myjekyllsite) {
require(knitr)
opts_knit$set(base.url = base.url)
fig.path <- paste0("figs/", sub(".Rmd$", "", basename(input)), "/")
opts_chunk$set(fig.path = fig.path)
opts_chunk$set(fig.cap = "center")
render_jekyll()
knit(input, envir = parent.frame())
}
KnitPost("test.Rmd")
install.packages("ggplot")
install.packages("ggplot2")
install.packages("tidyr")
plot(cars)
library(dplyr)
library(data.table)
library(ggplot2)
library(tidyr)
knitPost <- function(site.path='~/source/cnorval.github.io/', overwriteAll=F, overwriteOne=NULL) {
if(!'package:knitr' %in% search()) library('knitr')
## Blog-specific directories.  This will depend on how you organize your blog.
site.path <- site.path # directory of jekyll blog (including trailing slash)
rmd.path <- paste0(site.path, "_Rmd") # directory where your Rmd-files reside (relative to base)
fig.dir <- "assets/Rfig/" # directory to save figures
posts.path <- paste0(site.path, "_posts") # directory for converted markdown files
cache.path <- paste0(site.path, "_cache") # necessary for plots
render_jekyll(highlight = "pygments")
opts_knit$set(base.url = '/', base.dir = site.path)
opts_chunk$set(fig.path=fig.dir, fig.width=8.5, fig.height=5.25, dev='svg', cache=F,
warning=F, message=F, cache.path=cache.path, tidy=F)
setwd(rmd.path) # setwd to base
# some logic to help us avoid overwriting already existing md files
files.rmd <- data.frame(rmd = list.files(path = rmd.path,
full.names = T,
pattern = "\\.Rmd$",
ignore.case = T,
recursive = F), stringsAsFactors=F)
files.rmd$corresponding.md.file <- paste0(posts.path, "/", basename(gsub(pattern = "\\.Rmd$", replacement = ".md", x = files.rmd$rmd)))
files.rmd$corresponding.md.exists <- file.exists(files.rmd$corresponding.md.file)
## determining which posts to overwrite from parameters overwriteOne & overwriteAll
files.rmd$md.overwriteAll <- overwriteAll
if(is.null(overwriteOne)==F) files.rmd$md.overwriteAll[grep(overwriteOne, files.rmd[,'rmd'], ignore.case=T)] <- T
files.rmd$md.render <- F
for (i in 1:dim(files.rmd)[1]) {
if (files.rmd$corresponding.md.exists[i] == F) {
files.rmd$md.render[i] <- T
}
if ((files.rmd$corresponding.md.exists[i] == T) && (files.rmd$md.overwriteAll[i] == T)) {
files.rmd$md.render[i] <- T
}
}
# For each Rmd file, render markdown (contingent on the flags set above)
for (i in 1:dim(files.rmd)[1]) {
if (files.rmd$md.render[i] == T) {
out.file <- knit(as.character(files.rmd$rmd[i]),
output = as.character(files.rmd$corresponding.md.file[i]),
envir = parent.frame(),
quiet = T)
message(paste0("KnitPost(): ", basename(files.rmd$rmd[i])))
}
}
}
plot(cars)
```
plot(cars)
knitPost()
plot(cars)
```
plot(1)
plot(cars)
?knit
knitPost <- function(site.path='~/source/cnorval.github.io/', overwriteAll=F, overwriteOne=NULL) {
if(!'package:knitr' %in% search()) library('knitr')
## Blog-specific directories.  This will depend on how you organize your blog.
site.path <- site.path # directory of jekyll blog (including trailing slash)
rmd.path <- paste0(site.path, "_Rmd") # directory where your Rmd-files reside (relative to base)
#fig.dir <- "assets/Rfig/" # directory to save figures
fig.dir <- "_Rmd" # directory to save figures
posts.path <- paste0(site.path, "_posts") # directory for converted markdown files
cache.path <- paste0(site.path, "_cache") # necessary for plots
render_jekyll(highlight = "pygments")
opts_knit$set(base.url = '/', base.dir = site.path)
opts_chunk$set(fig.path=fig.dir, fig.width=8.5, fig.height=5.25, dev='svg', cache=F,
warning=F, message=F, cache.path=cache.path, tidy=F)
setwd(rmd.path) # setwd to base
# some logic to help us avoid overwriting already existing md files
files.rmd <- data.frame(rmd = list.files(path = rmd.path,
full.names = T,
pattern = "\\.Rmd$",
ignore.case = T,
recursive = F), stringsAsFactors=F)
files.rmd$corresponding.md.file <- paste0(posts.path, "/", basename(gsub(pattern = "\\.Rmd$", replacement = ".md", x = files.rmd$rmd)))
files.rmd$corresponding.md.exists <- file.exists(files.rmd$corresponding.md.file)
## determining which posts to overwrite from parameters overwriteOne & overwriteAll
files.rmd$md.overwriteAll <- overwriteAll
if(is.null(overwriteOne)==F) files.rmd$md.overwriteAll[grep(overwriteOne, files.rmd[,'rmd'], ignore.case=T)] <- T
files.rmd$md.render <- F
for (i in 1:dim(files.rmd)[1]) {
if (files.rmd$corresponding.md.exists[i] == F) {
files.rmd$md.render[i] <- T
}
if ((files.rmd$corresponding.md.exists[i] == T) && (files.rmd$md.overwriteAll[i] == T)) {
files.rmd$md.render[i] <- T
}
}
# For each Rmd file, render markdown (contingent on the flags set above)
for (i in 1:dim(files.rmd)[1]) {
if (files.rmd$md.render[i] == T) {
out.file <- knit(as.character(files.rmd$rmd[i]),
output = as.character(files.rmd$corresponding.md.file[i]),
envir = parent.frame(),
quiet = T)
message(paste0("KnitPost(): ", basename(files.rmd$rmd[i])))
}
}
}
knitPost()
knitPost()
knitPost()
knitPost <- function(site.path='~/source/cnorval.github.io/', overwriteAll=F, overwriteOne=NULL) {
if(!'package:knitr' %in% search()) library('knitr')
## Blog-specific directories.  This will depend on how you organize your blog.
site.path <- site.path # directory of jekyll blog (including trailing slash)
rmd.path <- paste0(site.path, "_Rmd") # directory where your Rmd-files reside (relative to base)
fig.dir <- "assets/Rfig/" # directory to save figures
posts.path <- paste0(site.path, "_posts") # directory for converted markdown files
cache.path <- paste0(site.path, "_cache") # necessary for plots
render_jekyll(highlight = "pygments")
opts_knit$set(base.url = '/', base.dir = site.path)
opts_chunk$set(fig.path=fig.dir, fig.width=8.5, fig.height=5.25, dev='svg', cache=F,
warning=F, message=F, cache.path=cache.path, tidy=F)
setwd(rmd.path) # setwd to base
# some logic to help us avoid overwriting already existing md files
files.rmd <- data.frame(rmd = list.files(path = rmd.path,
full.names = T,
pattern = "\\.Rmd$",
ignore.case = T,
recursive = F), stringsAsFactors=F)
files.rmd$corresponding.md.file <- paste0(posts.path, "/", basename(gsub(pattern = "\\.Rmd$", replacement = ".md", x = files.rmd$rmd)))
files.rmd$corresponding.md.exists <- file.exists(files.rmd$corresponding.md.file)
## determining which posts to overwrite from parameters overwriteOne & overwriteAll
files.rmd$md.overwriteAll <- overwriteAll
if(is.null(overwriteOne)==F) files.rmd$md.overwriteAll[grep(overwriteOne, files.rmd[,'rmd'], ignore.case=T)] <- T
files.rmd$md.render <- F
for (i in 1:dim(files.rmd)[1]) {
if (files.rmd$corresponding.md.exists[i] == F) {
files.rmd$md.render[i] <- T
}
if ((files.rmd$corresponding.md.exists[i] == T) && (files.rmd$md.overwriteAll[i] == T)) {
files.rmd$md.render[i] <- T
}
}
# For each Rmd file, render markdown (contingent on the flags set above)
for (i in 1:dim(files.rmd)[1]) {
if (files.rmd$md.render[i] == T) {
out.file <- knit(as.character(files.rmd$rmd[i]),
output = as.character(files.rmd$corresponding.md.file[i]),
envir = parent.frame(),
quiet = T)
message(paste0("KnitPost(): ", basename(files.rmd$rmd[i])))
}
}
}
knitPost()
getwd()
knitPost <- function(site.path='~/source/cnorval.github.io/', overwriteAll=F, overwriteOne=NULL) {
if(!'package:knitr' %in% search()) library('knitr')
## Blog-specific directories.  This will depend on how you organize your blog.
site.path <- site.path # directory of jekyll blog (including trailing slash)
rmd.path <- paste0(site.path, "_Rmd") # directory where your Rmd-files reside (relative to base)
fig.dir <- "assets/Rfig/" # directory to save figures
posts.path <- paste0(site.path, "_posts") # directory for converted markdown files
cache.path <- paste0(site.path, "_cache") # necessary for plots
render_jekyll(highlight = "pygments")
opts_knit$set(base.url = '/', base.dir = site.path)
opts_chunk$set(fig.path=fig.dir, fig.width=8.5, fig.height=5.25, dev='png', cache=F,
warning=F, message=F, cache.path=cache.path, tidy=F)
setwd(rmd.path) # setwd to base
# some logic to help us avoid overwriting already existing md files
files.rmd <- data.frame(rmd = list.files(path = rmd.path,
full.names = T,
pattern = "\\.Rmd$",
ignore.case = T,
recursive = F), stringsAsFactors=F)
files.rmd$corresponding.md.file <- paste0(posts.path, "/", basename(gsub(pattern = "\\.Rmd$", replacement = ".md", x = files.rmd$rmd)))
files.rmd$corresponding.md.exists <- file.exists(files.rmd$corresponding.md.file)
## determining which posts to overwrite from parameters overwriteOne & overwriteAll
files.rmd$md.overwriteAll <- overwriteAll
if(is.null(overwriteOne)==F) files.rmd$md.overwriteAll[grep(overwriteOne, files.rmd[,'rmd'], ignore.case=T)] <- T
files.rmd$md.render <- F
for (i in 1:dim(files.rmd)[1]) {
if (files.rmd$corresponding.md.exists[i] == F) {
files.rmd$md.render[i] <- T
}
if ((files.rmd$corresponding.md.exists[i] == T) && (files.rmd$md.overwriteAll[i] == T)) {
files.rmd$md.render[i] <- T
}
}
# For each Rmd file, render markdown (contingent on the flags set above)
for (i in 1:dim(files.rmd)[1]) {
if (files.rmd$md.render[i] == T) {
out.file <- knit(as.character(files.rmd$rmd[i]),
output = as.character(files.rmd$corresponding.md.file[i]),
envir = parent.frame(),
quiet = T)
message(paste0("KnitPost(): ", basename(files.rmd$rmd[i])))
}
}
}
getwd()
knitPost()
library(dplyr)
library(data.table)
library(ggplot2)
library(tidyr)
knitPost <- function(site.path='~/source/cnorval.github.io/', overwriteAll=F, overwriteOne=NULL) {
if(!'package:knitr' %in% search()) library('knitr')
## Blog-specific directories.  This will depend on how you organize your blog.
site.path <- site.path # directory of jekyll blog (including trailing slash)
rmd.path <- paste0(site.path, "_Rmd") # directory where your Rmd-files reside (relative to base)
fig.dir <- "assets/Rfig/" # directory to save figures
posts.path <- paste0(site.path, "_posts") # directory for converted markdown files
cache.path <- paste0(site.path, "_cache") # necessary for plots
render_jekyll(highlight = "pygments")
opts_knit$set(base.url = '/', base.dir = site.path)
opts_chunk$set(fig.path=fig.dir, fig.width=8.5, fig.height=5.25, dev='png', cache=F,
warning=F, message=F, cache.path=cache.path, tidy=F)
setwd(rmd.path) # setwd to base
# some logic to help us avoid overwriting already existing md files
files.rmd <- data.frame(rmd = list.files(path = rmd.path,
full.names = T,
pattern = "\\.Rmd$",
ignore.case = T,
recursive = F), stringsAsFactors=F)
files.rmd$corresponding.md.file <- paste0(posts.path, "/", basename(gsub(pattern = "\\.Rmd$", replacement = ".md", x = files.rmd$rmd)))
files.rmd$corresponding.md.exists <- file.exists(files.rmd$corresponding.md.file)
## determining which posts to overwrite from parameters overwriteOne & overwriteAll
files.rmd$md.overwriteAll <- overwriteAll
if(is.null(overwriteOne)==F) files.rmd$md.overwriteAll[grep(overwriteOne, files.rmd[,'rmd'], ignore.case=T)] <- T
files.rmd$md.render <- F
for (i in 1:dim(files.rmd)[1]) {
if (files.rmd$corresponding.md.exists[i] == F) {
files.rmd$md.render[i] <- T
}
if ((files.rmd$corresponding.md.exists[i] == T) && (files.rmd$md.overwriteAll[i] == T)) {
files.rmd$md.render[i] <- T
}
}
# For each Rmd file, render markdown (contingent on the flags set above)
for (i in 1:dim(files.rmd)[1]) {
if (files.rmd$md.render[i] == T) {
out.file <- knit(as.character(files.rmd$rmd[i]),
output = as.character(files.rmd$corresponding.md.file[i]),
envir = parent.frame(),
quiet = T)
message(paste0("KnitPost(): ", basename(files.rmd$rmd[i])))
}
}
}
